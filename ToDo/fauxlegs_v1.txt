@name fauxlegs_v1
@inputs [Hip Torso Footl Footr]:entity
@inputs X Y For Back Right Left Jump
@outputs [Camop Camov]:vector
#Position, Velocity, Acceleration
@persist [Pos Vel Acc]:vector
#Direction information
@persist [Dirv Rigv Camv Fr Fl Bl Br WallV]:vector Filtx Filty
@persist TempS
#Object Information
@persist [Curl Curr Footlt Footrt Hipt]:vector
@persist [Cuml Cumr Footlo Footro Hipo]:vector
@persist [HFl HFo HRl HRo HWF HWR]:vector
@persist [TFl TFo TRl TRo TWF TWR]:vector
@persist WVAng
#Bool Flags
@persist IsOnGround IsOnWall Rest Jcurrent Jlast
#Consts
@persist MaxH BoxSize MaxVel Jstr Natsp Acspd Gravity Damp BSchk ACM WJM
#Consts - anim
@persist SM MaxSz TM MaxTr Um Hm HFf HFr TFf TFr 
@persist Dran:ranger Time
#NOT NECESSARY FOR FUNCTION. I'M JUST USING IT TO PARENT TO
@model models\\cheeze\\wires\\cpu.mdl
@trigger none

interval(10)

if(first() | dupefinished())
{
    timer("invis", 5000)
    rangerPersist(1)
    rangerFilter(entity():getConstraints())

    #initial position
    if(Hip)
    {
        Pos = Hip:massCenter()    
    }
    else
    {
        Pos = entity():pos()
    }
    IsOnGround = 0
    IsOnWall = 0
    
    
    #Dirv = vec(cos(Filtx), sin(Filtx), 0)
    Dirv = vec(0, 1, 0)
    Rigv = vec(0, 0, -1):cross(Dirv)
    
    HFl = Hip:toLocal(Hip:massCenter() + Dirv * 100)
    HRl = Hip:toLocal(Hip:massCenter() + Rigv * 100)
    
    TFl = Torso:toLocal(Torso:massCenter() + Dirv * 100)
    TRl = Torso:toLocal(Torso:massCenter() + Rigv * 100)
    
    Curl = vec((Footl:massCenter() - Pos):dot(Dirv),(Footl:massCenter() - Pos):dot(Rigv), (Footl:massCenter() - Pos):dot(vec(0, 0, 1)))
    Curr = vec((Footr:massCenter() - Pos):dot(Dirv),(Footr:massCenter() - Pos):dot(Rigv), (Footr:massCenter() - Pos):dot(vec(0, 0, 1)))
    
    #Movement Persists
    
    if(Hip & Footl & Footr)
    {
        MaxH = abs(Hip:massCenter():z() - ((Footl:toWorld(Footl:boxCenter()):z()-Footl:boxSize():z()/2) + (Footr:toWorld(Footr:boxCenter()):z()-Footr:boxSize():z()/2))/2)
    }
    else
    {
        MaxH = 50
    }
    BoxSize = 30
    
    Acspd = 20
    Gravity = 600/66.6
    MaxVel = 600
    Jstr = 500
    Natsp = 10
    Damp = 0.05
    BSchk = 2
    
    ACM = 1
    WJM = 1.5
    
    #anim persists
    SM = 60
    MaxSz = 15
    
    TM = 36
    MaxTr = 12
    
    Um = 1
    Hm = 1
    
    HFf = 3
    HFr = 3
    
    TFf = 3
    TFr = 3
}

Time = Time + clamp(TM*(Vel:length()/MaxVel), 0, MaxTr)


if(clk())
{
    #Step 1: Which way am I going? (eyepod)
    Filtx = -X/4
    Filty = Y/4
    Dirv = vec(cos(Filtx), sin(Filtx), 0)
    Rigv = vec(0, 0, -1):cross(Dirv)
    Camv = vec(cos(Filtx)*cos(Filty), sin(Filtx)*cos(Filty), sin(Filty))
    #For Ranger Tests
    Fr = (Dirv + Rigv):normalized()
    Fl = (Dirv - Rigv):normalized()
    Bl = (-Dirv - Rigv):normalized()
    Br = (-Dirv + Rigv):normalized()
}
if(clk())
{
    #Step 2: Look down
    Dran = rangerOffset(Pos, Pos - MaxH * vec(0, 0, 1))
    if(Dran:hit())
    {
        if(Dran:distance() < (MaxH - 2))
        {
            Vel = Vel:setZ(Natsp*(MaxH - Dran:distance()))
        }
        else
        {
            Vel = Vel:setZ(0)
        }
        IsOnGround = 1
        
    }
    else
    {
        IsOnGround = 0
    }
}
#Step 3: Look up
if(clk())
{
    Dran = rangerOffset(Pos, Pos + MaxH * vec(0, 0, 1))
    if(Dran:hit())
    {
        Vel = Vel:setZ(0)
    }
}
#Step 4: Look Fl
IsOnWall = 0
WallV = vec()
if(clk())
{
    Dran = rangerOffset(Pos, Pos + Fl * BoxSize * BSchk)
    if(Dran:hit())
    {
        IsOnWall = 1
        if(Dran:distance() < BoxSize)
        {
            Vel = Vel - Fl * (Fl:dot(Vel) + (Natsp*(BoxSize - Dran:distance())))
        }
        WallV += Dran:hitNormal()
    }
}
#Step 5: Look Fr
if(clk())
{
    Dran = rangerOffset(Pos, Pos + Fr * BoxSize * BSchk)
    if(Dran:hit())
    {
        IsOnWall = 1
        if(Dran:distance() < BoxSize)
        {
            Vel = Vel - Fr * (Fr:dot(Vel) + (Natsp*(BoxSize - Dran:distance())))
        }
        WallV += Dran:hitNormal()
    }
}
#Step 6: Look Bl
if(clk())
{
    Dran = rangerOffset(Pos, Pos + Bl * BoxSize * BSchk)
    if(Dran:hit())
    {
        IsOnWall = 1
        if(Dran:distance() < BoxSize)
        {
            Vel = Vel - Bl * (Bl:dot(Vel) + (Natsp*(BoxSize - Dran:distance())))
        }
        WallV += Dran:hitNormal()
    }
}
#Step 7: Look Br
if(clk())
{
    Dran = rangerOffset(Pos, Pos + Br * BoxSize * BSchk)
    if(Dran:hit())
    {
        IsOnWall = 1
        if(Dran:distance() < BoxSize)
        {
            Vel = Vel - Br * (Br:dot(Vel) + (Natsp*(BoxSize - Dran:distance())))
        }
        WallV += Dran:hitNormal()
    }
}
#Step 8: Use this information to set Acc/Vel/Pos
Acc = ((For - Back) * Dirv + (Right - Left) * Rigv) * (Acspd) * (ACM)^(!IsOnGround) - !IsOnGround * (vec(0, 0, Gravity))
Acc -= Vel:setZ(0) * Damp/(1+!IsOnGround) * (!(For - Back) & !(Right - Left))
Vel += Acc

if(IsOnGround)
{
    IsOnWall = 0
    WallV = vec()
}

Jlast = Jcurrent
Jcurrent = Jump

if(Jcurrent & !Jlast & (IsOnGround | IsOnWall))
{
    if(WallV:setZ(0) != vec())
    {
        WallV = WallV:setZ(0):normalized()
    }
    TempS = Vel:length()
    Vel = Vel + (WallV + vec(0, 0, 1)):normalized() * Jstr * (WJM)^(IsOnWall)
    #Vel:setZ(Jstr)
    IsOnGround = 0
    IsOnWall = 0
}
if(Vel:setZ(0):length() > MaxVel)
{
    TempS = Vel:z()
    Vel = Vel:setZ(0):normalized() * MaxVel
    Vel = Vel + TempS * vec(0, 0, 1)
}
Pos += Vel * 0.01

#Let's make shit look like it's moving correctly!!

if(Hip & Footl & Footr)
{
    #Angle for Walljumpin'
    WVAng = WallV:setZ(0):normalized():dot(Rigv)
    #+ means +Right -Left
    #- means -Right +Left
    #MaxSz * Um
    
    Cuml = Pos + Curl:x() * Dirv + Curl:y() * Rigv + Curl:z() * vec(0, 0, 1) + IsOnWall * vec(0, 0, 1) * WVAng * MaxSz * Um
    Cumr = Pos + Curr:x() * Dirv + Curr:y() * Rigv + Curr:z() * vec(0, 0, 1) - IsOnWall * vec(0, 0, 1) * WVAng * MaxSz * Um
    if(Vel == vec())
    {
        Footlt = Cuml
        Footrt = Cumr
    }
    else
    {
        Footlt = Cuml + IsOnGround * clamp(SM*(Vel:length()/MaxVel), 0, MaxSz) * (Vel:normalized() * sin(Time) * Hm + vec(0, 0, 1) * cos(Time) * Um)
        Footrt = Cumr + IsOnGround * clamp(SM*(Vel:length()/MaxVel), 0, MaxSz) * (Vel:normalized() * sin(Time+180) * Hm + vec(0, 0, 1) * cos(Time+180) * Um)
    }
    Hipt = Pos
    
    #offsets
    Hipo = Hipt - Hip:massCenter()
    Footlo = Footlt - Footl:massCenter()
    Footro = Footrt - Footr:massCenter()
    
    Hip:applyForce(Hip:mass() * 4 * (Hipo + $Hipo * 5))
    Footl:applyForce(Footl:mass() * 4 * (Footlo + $Footlo * 5))
    Footr:applyForce(Footr:mass() * 4 * (Footro + $Footro * 5))
    
    #turning
    HWF = ((Hip:toWorld(HFl) - Hip:pos()):normalized()) * cos(!IsOnGround * clamp(Vel:z()/20, -15, 15)) - sin(!IsOnGround * clamp(Vel:z()/20, -15, 15)) * vec(0, 0, 1)
    HWR = (Hip:toWorld(HRl) - Hip:pos()):normalized()
    HFo = Dirv - HWF
    HRo = Rigv - HWR
    
    TWF = ((Torso:toWorld(TFl) - Torso:pos()):normalized()) * cos(!IsOnGround * clamp(Vel:z()/20, -15, 15)) - sin(!IsOnGround * clamp(Vel:z()/20, -15, 15)) * vec(0, 0, 1)
    TWR = (Torso:toWorld(TRl) - Torso:pos()):normalized()
    TFo = Camv - TWF
    TRo = Rigv - TWR
    
    Hip:applyOffsetForce((HFo + $HFo * 5) * Hip:mass() * HFf, Hip:massCenter() + HWF * 100)
    Hip:applyOffsetForce((HFo + $HFo * 5) * Hip:mass() * -HFf, Hip:massCenter() - HWF * 100)
    Hip:applyOffsetForce((HRo + $HRo * 5) * Hip:mass() * HFr, Hip:massCenter() + HWR * 100)
    Hip:applyOffsetForce((HRo + $HRo * 5) * Hip:mass() * -HFr, Hip:massCenter() - HWR * 100)
    
    Torso:applyOffsetForce((TFo + $TFo * 5) * Torso:mass() * TFf, Torso:massCenter() + TWF * 100)
    Torso:applyOffsetForce((TFo + $TFo * 5) * Torso:mass() * -TFf, Torso:massCenter() - TWF * 100)
    Torso:applyOffsetForce((TRo + $TRo * 5) * Torso:mass() * TFr, Torso:massCenter() + TWR * 100)
    Torso:applyOffsetForce((TRo + $TRo * 5) * Torso:mass() * -TFr, Torso:massCenter() - TWR * 100)
}
#Camera Stupid Shit
Camov = Camv
Camop = Pos

if(clk("invis"))
{
    entity():setAlpha(0)
}
